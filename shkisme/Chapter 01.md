# [1장] 코틀린이란 무엇이며, 왜 필요한가?

# 코틀린 맛보기

```kotlin
data class Person(val name: String, val age: Int? = null)

fun main(args: Array<String>){
    val persons = listOf(Person("영희"), Person("철수", age = 29))
    val oldest = persons.maxBy { it.age ?: 0 }
    println("나이가 가장 많은 사람 : $oldest") // 철수
}
```

엘비스 연산자(`?:`)를 사용하면 `null`이 들어왔을 때 다른 값으로 반환할 수 있어 null-safe한 코드를 작성할 수 있다.

처음에는 타입과 변수명의 순서가 반대라서 좀 생소했다.

# 코틀린의 주요 특성

## 대상 플랫폼 : 서버, 안드로이드 등 자바가 실행되는 모든 곳

자바가 사용되고 있는 모든 용도에 적합하고, 더 간결하고 생산적이며 안전한 대체 언어를 제공할 수 있다. 코틀린은 **상당히 광범위**하게 사용될 수 있다.

## 정적 타입 지정 언어

모든 프로그램 구성 요소의 **타입을 컴파일 시점에 알 수 있고**, 프로그램 안에서 객체의 필드나 메소드를 사용할 때 마다 컴파일러가 타입을 검증해준다.

### 타입 추론

```kotlin
var x = 1
```

### 정적 타입의 장점

- 성능이 빠르다.
- 컴파일러가 `정확성`을 검증하므로, 오류가 적다.
- 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있으므로, 유지보수가 쉽다.
- 안전한 `리팩토링`이 가능하다.

### Null이 될 수 있는 타입을 지원한다.

컴파일 시점에 `Null 포인터 예외`가 발생할 수 있는지 여부를 검사할 수 있다.

## 함수형 프로그래밍

### 함수형 프로그래밍의 핵심 개념은 무엇일까.

- 일급 시민인 **함수**를 일반 **값**처럼 다룰 수 있다.
    
    함수를 **변수에 저장**, **다른 함수에 전달할 수 있으며,** **함수 안에서 함수를 만들어서 반환**할 수 있다.
    
- `불변성`
    
    만들어지고 나면, 내부 상태가 절대로 바뀌지 않는 **불변 객체**를 사용해 프로그램을 작성한다.
    
- `부수 효과 없음`
    
    입력이 같으면 항상 같은 출력을 내놓고 **다른 객체의 상태를 변경하지 않는다.**
    

### 함수형 스타일로 프로그래밍 했을 때의 장점은 무엇인가.

1. 간결하다. 가독성이 좋다.
2. 다중 스레드를 사용해도 안전하다.
3. **부수 효과가 없으므로, `순수 함수`는 그 자체로 테스트가 가능하다. 테스트가 쉽다.**

### 순수 함수?

- 같은 매개변수 값으로 이용하면 항상 같은 값의 출력이 나오는 함수.
- 별도의 입출력이 필요 없다.
- 함수 외부에서 다른 값을 변경하지 않는다.

```kotlin
fun add(a: Int, b: Int) {
		return a + b
}
```

# 코틀린 응용

### 계속해서 강조하는 신뢰성.

코틀린 타입 시스템은 `null` 값을 정확히 추적하며, 널 포인터로 인해 생기는 문제를 줄여준다. **자바에서 `NullPointerException`을 일으키는 유형의 코드는 대부분 코틀린에서는 컴파일 되지도 않는다.**

대부분의 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝하므로, 람다를 사용해도 새로운 객체가 만들어지지 않으므로, 객체 증가로 인해 가비지 컬렉션이 늘어날 일도 없다.

# 코틀린의 철학

## 실용성

코틀린은 다른 프로그래밍 언어가 채택한, 이미 성공적으로 검증된 해법과 기능에 의존한다. 언어의 복잡도는 줄어들고, 이미 알고 있는 기존 개념을 통해 쉽게 배울 수 있다.

**코틀린의 경우 인텔리제이 아이디어의 개발과 컴파일러 개발이 맞물려 있다**. 항상 도구의 활용을 염두에 두고 설계되어 왔다.

## 간결성

**게터, 세터, 생성자 등등의 번거러운 준비 코드를 코틀린은 묵시적으로 제공한다.**

코틀린은 **다양한 표준 라이브러리를 제공**하기 때문에, 반복되거나 길어질 수 있는 코드를 라이브러리 함수 호출로 대치할 수 있다.

## 안전성

자바보다 더 적은 비용으로 타입 안전성을 사용할 수 있고, 대부분 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 타입 정보를 직접 지정할 필요가 없다.

비용이 컸던 자바의 Optional보다 좋음을 말하는 듯 하다.

### `Null` 에 민감한 코틀린.

실행 시점에 `NullPointerException`이 발생할 수 있는 연산을 사용하는 코드를 금지한다. 그러면서도, 비용은 미미하다.

```kotlin
val s : String? = null // 널이 될 수 있음.
val s2 : String = "" // 널이 될 수 없음.
```

### `ClassCastException`

코틀린에서는 **타입 검사와 캐스트가 한 연산자에 의해 이뤄진다.** 어떤 객체의 타입을 검사했고, 그 객체가 그 타입에 속한다면 해당 타입의 메소드나 필드 등의 멤버를 별도의 캐스트 없이 사용할 수 있다.

```kotlin
if (value is String) // 타입 검사
	println(value.toUpperCase()) // 해당 타입의 메소드를 사용한다.
```

# 코틀린 도구 사용

## 코틀린 코드 컴파일

코틀린 컴파일러로 컴파일한 코드는 **코틀린 런타임 라이브러리에 의존**한다.

코틀린을 컴파일하기 위해 메이븐, 그레이들, 앤트 등의 빌드 시스템을 사용할 것인데, 코틀린은 그런 빌드 시스템과 호환된다.
